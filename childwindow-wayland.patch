From 48e47d06fd6b7daf90c0b664ab7967e98512e5d6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 Jun 2024 21:22:18 +0200
Subject: [PATCH 1/3] winewayland: Post WM_WAYLAND_CONFIGURE outside of the
 surface lock.

---
 dlls/winewayland.drv/wayland_surface.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 39c3976cdfd..5e7b04842f6 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -38,7 +38,7 @@ static void xdg_surface_handle_configure(void *data, struct xdg_surface *xdg_sur
                                          uint32_t serial)
 {
     struct wayland_surface *surface;
-    BOOL initial_configure = FALSE;
+    BOOL should_post = FALSE, initial_configure = FALSE;
     HWND hwnd = data;
 
     TRACE("serial=%u\n", serial);
@@ -52,16 +52,17 @@ static void xdg_surface_handle_configure(void *data, struct xdg_surface *xdg_sur
         /* If we have a previously requested config, we have already sent a
          * WM_WAYLAND_CONFIGURE which hasn't been handled yet. In that case,
          * avoid sending another message to reduce message queue traffic. */
-        BOOL should_post = surface->requested.serial == 0;
+        should_post = surface->requested.serial == 0;
         initial_configure = surface->current.serial == 0;
         surface->pending.serial = serial;
         surface->requested = surface->pending;
         memset(&surface->pending, 0, sizeof(surface->pending));
-        if (should_post) NtUserPostMessage(hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
     }
 
     pthread_mutex_unlock(&surface->mutex);
 
+    if (should_post) NtUserPostMessage(hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
+
     /* Flush the window surface in case there is content that we weren't
      * able to flush before due to the lack of the initial configure. */
     if (initial_configure) wayland_window_flush(hwnd);
-- 
GitLab


From be30ffb53e5955ee1c08535bd564b75d27f28060 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 Jun 2024 20:23:44 +0200
Subject: [PATCH 2/3] winewayland: Use WL_SHM_FORMAT_ARGB8888 format for window
 surfaces.

---
 dlls/winewayland.drv/window_surface.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index e9eb74b17ca..3b354925a8e 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -154,7 +154,7 @@ static struct wayland_shm_buffer *wayland_buffer_queue_get_free_buffer(struct wa
         if (nbuffers < 3)
         {
             shm_buffer = wayland_shm_buffer_create(queue->width, queue->height,
-                                                   WL_SHM_FORMAT_XRGB8888);
+                                                   WL_SHM_FORMAT_ARGB8888);
             if (shm_buffer)
             {
                 /* Buffer events go to their own queue so that we can dispatch
@@ -262,7 +262,7 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
     {
         const char *src;
         char *dst;
-        int y, width_bytes, height;
+        int x, y, width_bytes, height;
         RECT rc;
 
         TRACE("rect %s\n", wine_dbgstr_rect(rgn_rect));
@@ -279,12 +279,14 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
         if (width_bytes == src_stride && width_bytes == dst_stride)
         {
             memcpy(dst, src, height * width_bytes);
+            for (x = 3; x < height * width_bytes; x += bpp) dst[x] = 0xff;
             continue;
         }
 
         for (y = 0; y < height; y++)
         {
             memcpy(dst, src, width_bytes);
+            for (x = 3; x < width_bytes; x += bpp) dst[x] = 0xff;
             src += src_stride;
             dst += dst_stride;
         }
-- 
GitLab


From da62d425afbd1e50463280dd87c427048d8d2a5e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 Jun 2024 20:23:44 +0200
Subject: [PATCH 3/3] winewayland: Implement window surface shape and color
 keying.

---
 dlls/winewayland.drv/window_surface.c | 29 +++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 3b354925a8e..961ba511c7a 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -317,6 +317,34 @@ static void wayland_shm_buffer_copy(struct wayland_shm_buffer *src,
     copy_pixel_region(src->map_data, &src_rect, dst->map_data, &dst_rect, region);
 }
 
+/**********************************************************************
+ *          wayland_shm_buffer_copy_data
+ */
+static void wayland_shm_buffer_copy_shape(struct wayland_shm_buffer *buffer, const RECT *dirty,
+                                          const BITMAPINFO *shape_info, const void *shape_bits)
+{
+    RECT dst_rect = {0, 0, buffer->width, buffer->height};
+    UINT32 *color, shape_stride, color_stride, x, y;
+    const BYTE *shape;
+    RECT rect;
+
+    shape_stride = shape_info->bmiHeader.biSizeImage / abs(shape_info->bmiHeader.biHeight);
+    color_stride = dst_rect.right - dst_rect.left;
+
+    if (!intersect_rect(&rect, &dst_rect, dirty)) return;
+
+    color = (UINT32 *)buffer->map_data + rect.top * color_stride;
+    shape = (const BYTE *)shape_bits + rect.top * shape_stride;
+
+    for (y = rect.top; y < rect.bottom; y++, color += color_stride, shape += shape_stride)
+    {
+        for (x = rect.left; x < rect.right; x++)
+        {
+            if (!(shape[x / 8] & (1 << (7 - (x & 7))))) color[x] = 0;
+        }
+    }
+}
+
 /***********************************************************************
  *           wayland_window_surface_flush
  */
@@ -387,6 +415,7 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
     }
 
     wayland_shm_buffer_copy_data(shm_buffer, color_bits, &surface_rect, copy_from_window_region);
+    if (shape_bits) wayland_shm_buffer_copy_shape(shm_buffer, rect, shape_info, shape_bits);
 
     pthread_mutex_lock(&wws->wayland_surface->mutex);
     if (wayland_surface_reconfigure(wws->wayland_surface))
-- 
GitLab

From 8cc619843cfef57d330123b2b7cc83b3382923e0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 11 Jul 2024 14:47:41 +0300
Subject: [PATCH 1/8] winewayland: Store visible_rect in wayland_win_data.

This allows wayland_win_data_update_wayland_surface() to be called
outside of WAYLAND_WindowPosChange, which will be needed in upcoming
commits.
---
 dlls/winewayland.drv/waylanddrv.h |  1 +
 dlls/winewayland.drv/window.c     | 17 +++++++++++------
 2 files changed, 12 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index efb13821696..c25f5775762 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -294,6 +294,7 @@ struct wayland_win_data
     RECT window_rect;
     /* USER client rectangle relative to win32 parent window client area */
     RECT client_rect;
+    RECT visible_rect;
     BOOL managed;
 };
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index dc6a6b7e03a..fda7139283f 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -78,7 +78,8 @@ static struct rb_tree win_data_rb = { wayland_win_data_cmp_rb };
  */
 static struct wayland_win_data *wayland_win_data_create(HWND hwnd,
                                                         const RECT *window_rect,
-                                                        const RECT *client_rect)
+                                                        const RECT *client_rect,
+                                                        const RECT *visible_rect)
 {
     struct wayland_win_data *data;
     struct rb_entry *rb_entry;
@@ -94,6 +95,7 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd,
     data->hwnd = hwnd;
     data->window_rect = *window_rect;
     data->client_rect = *client_rect;
+    data->visible_rect = *visible_rect;
 
     pthread_mutex_lock(&win_data_mutex);
 
@@ -200,14 +202,14 @@ static void reapply_cursor_clipping(void)
     NtUserSetThreadDpiAwarenessContext(context);
 }
 
-static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data, const RECT *visible_rect)
+static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
 {
     struct wayland_surface *surface = data->wayland_surface;
     HWND parent = NtUserGetAncestor(data->hwnd, GA_PARENT);
     BOOL visible, xdg_visible;
     WCHAR text[1024];
 
-    TRACE("hwnd=%p, rect=%s\n", data->hwnd, wine_dbgstr_rect(visible_rect));
+    TRACE("hwnd=%p\n", data->hwnd);
 
     /* We don't want wayland surfaces for child windows. */
     if (parent != NtUserGetDesktopWindow() && parent != 0)
@@ -251,7 +253,8 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
     pthread_mutex_unlock(&surface->mutex);
 
     if (data->window_surface)
-        wayland_window_surface_update_wayland_surface(data->window_surface, visible_rect, surface);
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      &data->visible_rect, surface);
 
     /* Size/position changes affect the effective pointer constraint, so update
      * it as needed. */
@@ -438,7 +441,8 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const REC
           hwnd, swp_flags, shaped, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
           wine_dbgstr_rect(visible_rect));
 
-    if (!data && !(data = wayland_win_data_create(hwnd, window_rect, client_rect))) return FALSE; /* use default surface */
+    if (!data && !(data = wayland_win_data_create(hwnd, window_rect, client_rect, visible_rect)))
+        return FALSE; /* use default surface */
 
     parent = NtUserGetAncestor(hwnd, GA_PARENT);
     if ((parent && parent != NtUserGetDesktopWindow())) goto done; /* use default surface */
@@ -475,13 +479,14 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
 
     data->window_rect = *window_rect;
     data->client_rect = *client_rect;
+    data->visible_rect = *visible_rect;
     data->managed = managed;
 
     if (surface) window_surface_add_ref(surface);
     if (data->window_surface) window_surface_release(data->window_surface);
     data->window_surface = surface;
 
-    wayland_win_data_update_wayland_surface(data, visible_rect);
+    wayland_win_data_update_wayland_surface(data);
     if (data->wayland_surface) wayland_win_data_update_wayland_state(data);
 
     wayland_win_data_release(data);
-- 
GitLab


From 8fb239e8dda6305bc059e650443593d83e703f6e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 11 Jul 2024 17:36:39 +0300
Subject: [PATCH 2/8] winewayland: Create subsurfaces for child windows.

Create (possibly nested) Wayland subsurfaces for all child windows,
to allow GL/VK contents to be presented onto them.
---
 dlls/winewayland.drv/wayland_surface.c | 61 +++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      | 12 +++++
 dlls/winewayland.drv/window.c          | 69 +++++++++++++++++---------
 3 files changed, 119 insertions(+), 23 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 39c3976cdfd..de3307ec51e 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -218,6 +218,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         surface->xdg_surface = NULL;
     }
 
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
     if (surface->wl_surface)
     {
         wl_surface_destroy(surface->wl_surface);
@@ -253,6 +259,7 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface)
     surface->xdg_toplevel = xdg_surface_get_toplevel(surface->xdg_surface);
     if (!surface->xdg_toplevel) goto err;
     xdg_toplevel_add_listener(surface->xdg_toplevel, &xdg_toplevel_listener, surface->hwnd);
+    surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
 
     if (process_name)
         xdg_toplevel_set_app_id(surface->xdg_toplevel, process_name);
@@ -267,6 +274,53 @@ err:
     ERR("Failed to assign toplevel role to wayland surface\n");
 }
 
+/**********************************************************************
+ *          wayland_surface_make_subsurface
+ *
+ * Gives the subsurface role to a plain wayland surface.
+ */
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent)
+{
+    struct wl_region *empty_region;
+
+    TRACE("surface=%p parent=%p\n", surface, parent);
+
+    surface->wl_subsurface =
+        wl_subcompositor_get_subsurface(process_wayland.wl_subcompositor,
+                                        surface->wl_surface,
+                                        parent->wl_surface);
+    if (!surface->wl_subsurface)
+    {
+        ERR("Failed to create client wl_subsurface\n");
+        goto err;
+    }
+
+    surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+    surface->parent_hwnd = parent->hwnd;
+
+    /* Let parent handle all pointer events. */
+    empty_region = wl_compositor_create_region(process_wayland.wl_compositor);
+    if (!empty_region)
+    {
+        ERR("Failed to create wl_region\n");
+        goto err;
+    }
+    wl_surface_set_input_region(surface->wl_surface, empty_region);
+    wl_region_destroy(empty_region);
+
+    /* Present contents independently of the parent surface. */
+    wl_subsurface_set_desync(surface->wl_subsurface);
+
+    wl_display_flush(process_wayland.wl_display);
+
+    return;
+
+err:
+    wayland_surface_clear_role(surface);
+    ERR("Failed to assign subsurface role to wayland surface\n");
+}
+
 /**********************************************************************
  *          wayland_surface_clear_role
  *
@@ -290,10 +344,17 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
         surface->xdg_surface = NULL;
     }
 
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
     memset(&surface->pending, 0, sizeof(surface->pending));
     memset(&surface->requested, 0, sizeof(surface->requested));
     memset(&surface->processing, 0, sizeof(surface->processing));
     memset(&surface->current, 0, sizeof(surface->current));
+    surface->parent_hwnd = 0;
 
     /* Ensure no buffer is attached, otherwise future role assignments may fail. */
     wl_surface_attach(surface->wl_surface, NULL, 0, 0);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c25f5775762..87d071707a8 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -73,6 +73,13 @@ enum wayland_surface_config_state
     WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN = (1 << 3)
 };
 
+enum wayland_surface_role
+{
+    WAYLAND_SURFACE_ROLE_NONE,
+    WAYLAND_SURFACE_ROLE_TOPLEVEL,
+    WAYLAND_SURFACE_ROLE_SUBSURFACE,
+};
+
 struct wayland_keyboard
 {
     struct wl_keyboard *wl_keyboard;
@@ -195,6 +202,7 @@ struct wayland_surface
     struct wl_surface *wl_surface;
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
+    struct wl_subsurface *wl_subsurface;
     struct wp_viewport *wp_viewport;
     pthread_mutex_t mutex;
     struct wayland_surface_config pending, requested, processing, current;
@@ -204,6 +212,8 @@ struct wayland_surface
     struct wayland_client_surface *client;
     int buffer_width, buffer_height;
     HCURSOR hcursor;
+    enum wayland_surface_role role;
+    HWND parent_hwnd;
 };
 
 struct wayland_shm_buffer
@@ -239,6 +249,8 @@ void wayland_output_use_xdg_extension(struct wayland_output *output);
 struct wayland_surface *wayland_surface_create(HWND hwnd);
 void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_make_toplevel(struct wayland_surface *surface);
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent);
 void wayland_surface_clear_role(struct wayland_surface *surface);
 void wayland_surface_attach_shm(struct wayland_surface *surface,
                                 struct wayland_shm_buffer *shm_buffer,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index fda7139283f..9be98363ac8 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -134,19 +134,32 @@ static void wayland_win_data_destroy(struct wayland_win_data *data)
 }
 
 /***********************************************************************
- *           wayland_win_data_get
+ *           wayland_win_data_get_nolock
  *
- * Lock and return the data structure associated with a window.
+ * Return the data structure associated with a window. This function does
+ * not lock the win_data_mutex, so it must be externally synchronized.
  */
-struct wayland_win_data *wayland_win_data_get(HWND hwnd)
+static struct wayland_win_data *wayland_win_data_get_nolock(HWND hwnd)
 {
     struct rb_entry *rb_entry;
 
-    pthread_mutex_lock(&win_data_mutex);
-
     if ((rb_entry = rb_get(&win_data_rb, hwnd)))
         return RB_ENTRY_VALUE(rb_entry, struct wayland_win_data, entry);
 
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_win_data_get
+ *
+ * Lock and return the data structure associated with a window.
+ */
+struct wayland_win_data *wayland_win_data_get(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    pthread_mutex_lock(&win_data_mutex);
+    if ((data = wayland_win_data_get_nolock(hwnd))) return data;
     pthread_mutex_unlock(&win_data_mutex);
 
     return NULL;
@@ -205,38 +218,42 @@ static void reapply_cursor_clipping(void)
 static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
 {
     struct wayland_surface *surface = data->wayland_surface;
-    HWND parent = NtUserGetAncestor(data->hwnd, GA_PARENT);
-    BOOL visible, xdg_visible;
+    struct wayland_win_data *parent_data;
+    enum wayland_surface_role role;
     WCHAR text[1024];
 
     TRACE("hwnd=%p\n", data->hwnd);
 
-    /* We don't want wayland surfaces for child windows. */
-    if (parent != NtUserGetDesktopWindow() && parent != 0)
+    if (NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_VISIBLE)
     {
-        if (data->window_surface)
-            wayland_window_surface_update_wayland_surface(data->window_surface, NULL, NULL);
-        if (surface) wayland_surface_destroy(surface);
-        surface = NULL;
-        goto out;
+        parent_data = wayland_win_data_get_nolock(NtUserGetAncestor(data->hwnd, GA_PARENT));
+        if (parent_data && parent_data->wayland_surface)
+            role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+        else
+            role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
     }
+    else
+        role = WAYLAND_SURFACE_ROLE_NONE;
 
-    /* Otherwise ensure that we have a wayland surface. */
-    if (!surface && !(surface = wayland_surface_create(data->hwnd))) return;
+    /* We can temporarily remove a role from a wayland surface and add it back,
+     * but we can't change a surface's role.
+     * TODO: Recreate the surface to allow role change. */
+    if (surface && role && surface->role && role != surface->role) goto out;
 
-    visible = (NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_VISIBLE) == WS_VISIBLE;
-    xdg_visible = surface->xdg_toplevel != NULL;
+    /* Ensure that we have a wayland surface. */
+    if (!surface && !(surface = wayland_surface_create(data->hwnd))) goto out;
 
     pthread_mutex_lock(&surface->mutex);
 
-    if (visible != xdg_visible)
+    if ((role == WAYLAND_SURFACE_ROLE_TOPLEVEL) != !!(surface->xdg_toplevel) ||
+        (role == WAYLAND_SURFACE_ROLE_SUBSURFACE) != !!(surface->wl_subsurface) ||
+        (role == WAYLAND_SURFACE_ROLE_SUBSURFACE && surface->parent_hwnd != parent_data->hwnd))
     {
         /* If we have a pre-existing surface ensure it has no role. */
         if (data->wayland_surface) wayland_surface_clear_role(surface);
-        /* If the window is a visible toplevel make it a wayland
-         * xdg_toplevel. Otherwise keep it role-less to avoid polluting the
-         * compositor with empty xdg_toplevels. */
-        if (visible)
+        /* If the window is visible give it a role, otherwise keep it role-less
+         * to avoid polluting the compositor with unused role objects. */
+        if (role == WAYLAND_SURFACE_ROLE_TOPLEVEL)
         {
             wayland_surface_make_toplevel(surface);
             if (surface->xdg_toplevel)
@@ -246,6 +263,12 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
                 wayland_surface_set_title(surface, text);
             }
         }
+        else if (role == WAYLAND_SURFACE_ROLE_SUBSURFACE)
+        {
+            pthread_mutex_lock(&parent_data->wayland_surface->mutex);
+            wayland_surface_make_subsurface(surface, parent_data->wayland_surface);
+            pthread_mutex_unlock(&parent_data->wayland_surface->mutex);
+        }
     }
 
     wayland_win_data_get_config(data, &surface->window);
-- 
GitLab


From 9d197ac7f732f9975aba25d1f88d41eb9052a09f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 11 Jul 2024 17:37:18 +0300
Subject: [PATCH 3/8] winewayland: Handle subsurface reconfiguration.

---
 dlls/winewayland.drv/wayland_surface.c | 99 +++++++++++++++++++++-----
 dlls/winewayland.drv/window.c          | 11 ++-
 2 files changed, 91 insertions(+), 19 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index de3307ec51e..425c270099e 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -568,6 +568,7 @@ static void wayland_surface_reconfigure_client(struct wayland_surface *surface)
     TRACE("hwnd=%p subsurface=%d,%d+%dx%d\n", surface->hwnd, x, y, width, height);
 
     wl_subsurface_set_position(surface->client->wl_subsurface, x, y);
+    wl_subsurface_place_above(surface->client->wl_subsurface, surface->wl_surface);
 
     if (surface->client->wp_viewport)
     {
@@ -589,29 +590,15 @@ static void wayland_surface_reconfigure_client(struct wayland_surface *surface)
 }
 
 /**********************************************************************
- *          wayland_surface_reconfigure
+ *          wayland_surface_reconfigure_xdg
  *
- * Reconfigures the wayland surface as needed to match the latest requested
+ * Reconfigures the xdg surface as needed to match the latest requested
  * state.
  */
-BOOL wayland_surface_reconfigure(struct wayland_surface *surface)
+static BOOL wayland_surface_reconfigure_xdg(struct wayland_surface *surface,
+                                            int width, int height)
 {
     struct wayland_window_config *window = &surface->window;
-    int win_width, win_height, width, height;
-
-    if (!surface->xdg_toplevel) return TRUE;
-
-    win_width = surface->window.rect.right - surface->window.rect.left;
-    win_height = surface->window.rect.bottom - surface->window.rect.top;
-
-    wayland_surface_coords_from_window(surface, win_width, win_height,
-                                       &width, &height);
-
-    TRACE("hwnd=%p window=%dx%d,%#x processing=%dx%d,%#x current=%dx%d,%#x\n",
-          surface->hwnd, win_width, win_height, window->state,
-          surface->processing.width, surface->processing.height,
-          surface->processing.state, surface->current.width,
-          surface->current.height, surface->current.state);
 
     /* Acknowledge any compatible processed config. */
     if (surface->processing.serial && surface->processing.processed &&
@@ -644,6 +631,82 @@ BOOL wayland_surface_reconfigure(struct wayland_surface *surface)
     }
 
     wayland_surface_reconfigure_geometry(surface, width, height);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_subsurface
+ *
+ * Reconfigures the subsurface as needed to match the latest requested
+ * state.
+ */
+static void wayland_surface_reconfigure_subsurface(struct wayland_surface *surface)
+{
+    struct wayland_surface *parent;
+    int local_x, local_y, x, y;
+
+    /* TODO: Locking the parent surface using the HWND may lead to a deadlock,
+     * since we will try to acquire the win_data_mutex while holding a surface
+     * mutex (from the argument of this function), whereas all other paths
+     * acquire the win_data_mutex before any surface mutex. */
+    if (surface->processing.serial && surface->processing.processed &&
+        (parent = wayland_surface_lock_hwnd(surface->parent_hwnd)))
+    {
+        /* For now we use a subsurface only for child windows, whose window
+         * coordinates are relative to the client area of their parent. */
+        local_x = surface->window.rect.left +
+                  (parent->window.client_rect.left - parent->window.rect.left);
+        local_y = surface->window.rect.top +
+                  (parent->window.client_rect.top - parent->window.rect.top);
+        wayland_surface_coords_from_window(surface, local_x, local_y, &x, &y);
+
+        TRACE("hwnd=%p pos=%d,%d\n", surface->hwnd, x, y);
+
+        wl_subsurface_set_position(surface->wl_subsurface, x, y);
+        if (parent->client)
+            wl_subsurface_place_above(surface->wl_subsurface, parent->client->wl_surface);
+        else
+            wl_subsurface_place_above(surface->wl_subsurface, parent->wl_surface);
+        wl_surface_commit(parent->wl_surface);
+
+        pthread_mutex_unlock(&parent->mutex);
+
+        memset(&surface->processing, 0, sizeof(surface->processing));
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure
+ *
+ * Reconfigures the wayland surface as needed to match the latest requested
+ * state.
+ */
+BOOL wayland_surface_reconfigure(struct wayland_surface *surface)
+{
+    int win_width, win_height, width, height;
+
+    win_width = surface->window.rect.right - surface->window.rect.left;
+    win_height = surface->window.rect.bottom - surface->window.rect.top;
+
+    wayland_surface_coords_from_window(surface, win_width, win_height,
+                                       &width, &height);
+
+    TRACE("hwnd=%p window=%dx%d,%#x processing=%dx%d,%#x current=%dx%d,%#x\n",
+          surface->hwnd, win_width, win_height, surface->window.state,
+          surface->processing.width, surface->processing.height,
+          surface->processing.state, surface->current.width,
+          surface->current.height, surface->current.state);
+
+    if (surface->xdg_toplevel)
+    {
+        if (!wayland_surface_reconfigure_xdg(surface, width, height)) return FALSE;
+    }
+    else if (surface->wl_subsurface)
+    {
+        wayland_surface_reconfigure_subsurface(surface);
+    }
+
     wayland_surface_reconfigure_size(surface, width, height);
     wayland_surface_reconfigure_client(surface);
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 9be98363ac8..6ee3707357a 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -295,7 +295,16 @@ static void wayland_win_data_update_wayland_state(struct wayland_win_data *data)
 
     pthread_mutex_lock(&surface->mutex);
 
-    if (!surface->xdg_toplevel) goto out;
+    if (surface->wl_subsurface)
+    {
+        TRACE("hwnd=%p subsurface parent=%p\n", surface->hwnd, surface->parent_hwnd);
+        /* Although subsurfaces don't have a dedicated surface config mechanism,
+         * we use the config fields to mark them as updated. */
+        surface->processing.serial = 1;
+        surface->processing.processed = TRUE;
+        goto out;
+    }
+    else if (!surface->xdg_toplevel) goto out;
 
     processing_config = surface->processing.serial &&
                         !surface->processing.processed;
-- 
GitLab


From fc5134eb61797365164fc3f854d50ae00395d776 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 22 Jul 2024 11:57:53 +0300
Subject: [PATCH 4/8] winewayland: Use weak references for parent
 wayland_surfaces.

Don't access the parent wayland_surface through their HWND while holding
a lock to the child surface, since this requires acquiring the
win_data_mutex and may lead to a deadlock.

Instead introduce a weak reference mechanism and use that to directly
access the parent wayland_surface.
---
 dlls/winewayland.drv/wayland_surface.c | 58 +++++++++++++++++++++-----
 dlls/winewayland.drv/waylanddrv.h      |  7 +++-
 dlls/winewayland.drv/window.c          |  6 ++-
 3 files changed, 58 insertions(+), 13 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 425c270099e..57fd217e0d3 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -168,6 +168,7 @@ struct wayland_surface *wayland_surface_create(HWND hwnd)
     }
 
     surface->window.scale = 1.0;
+    surface->weak_ref = 1;
 
     return surface;
 
@@ -176,6 +177,43 @@ err:
     return NULL;
 }
 
+/**********************************************************************
+ *          wayland_surface_get_weak_ref
+ *
+ * Gets a weak reference to a wayland_surface.
+ */
+struct wayland_surface *wayland_surface_get_weak_ref(struct wayland_surface *surface)
+{
+    InterlockedIncrement(&surface->weak_ref);
+    return surface;
+}
+
+/**********************************************************************
+ *          wayland_surface_get_weak_ref
+ *
+ * Releases a weak reference to a wayland_surface.
+ */
+void wayland_surface_release_weak_ref(struct wayland_surface *surface)
+{
+    if (InterlockedDecrement(&surface->weak_ref) > 0) return;
+    pthread_mutex_destroy(&surface->mutex);
+    free(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_lock_weak_ref
+ *
+ * Returns a locked wayland_surface from a weak reference, or NULL if the
+ * surface has been destroyed.
+ */
+struct wayland_surface *wayland_surface_lock_weak_ref(struct wayland_surface *surface)
+{
+    pthread_mutex_lock(&surface->mutex);
+    if (!surface->destroyed) return surface;
+    pthread_mutex_unlock(&surface->mutex);
+    return NULL;
+}
+
 /**********************************************************************
  *          wayland_surface_destroy
  *
@@ -237,9 +275,7 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
     wl_display_flush(process_wayland.wl_display);
 
-    pthread_mutex_destroy(&surface->mutex);
-
-    free(surface);
+    wayland_surface_release_weak_ref(surface);
 }
 
 /**********************************************************************
@@ -297,7 +333,7 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
     }
 
     surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
-    surface->parent_hwnd = parent->hwnd;
+    surface->parent_weak_ref = wayland_surface_get_weak_ref(parent);
 
     /* Let parent handle all pointer events. */
     empty_region = wl_compositor_create_region(process_wayland.wl_compositor);
@@ -350,11 +386,16 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
         surface->wl_subsurface = NULL;
     }
 
+    if (surface->parent_weak_ref)
+    {
+        wayland_surface_release_weak_ref(surface->parent_weak_ref);
+        surface->parent_weak_ref = NULL;
+    }
+
     memset(&surface->pending, 0, sizeof(surface->pending));
     memset(&surface->requested, 0, sizeof(surface->requested));
     memset(&surface->processing, 0, sizeof(surface->processing));
     memset(&surface->current, 0, sizeof(surface->current));
-    surface->parent_hwnd = 0;
 
     /* Ensure no buffer is attached, otherwise future role assignments may fail. */
     wl_surface_attach(surface->wl_surface, NULL, 0, 0);
@@ -646,12 +687,9 @@ static void wayland_surface_reconfigure_subsurface(struct wayland_surface *surfa
     struct wayland_surface *parent;
     int local_x, local_y, x, y;
 
-    /* TODO: Locking the parent surface using the HWND may lead to a deadlock,
-     * since we will try to acquire the win_data_mutex while holding a surface
-     * mutex (from the argument of this function), whereas all other paths
-     * acquire the win_data_mutex before any surface mutex. */
     if (surface->processing.serial && surface->processing.processed &&
-        (parent = wayland_surface_lock_hwnd(surface->parent_hwnd)))
+        surface->parent_weak_ref &&
+        (parent = wayland_surface_lock_weak_ref(surface->parent_weak_ref)))
     {
         /* For now we use a subsurface only for child windows, whose window
          * coordinates are relative to the client area of their parent. */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 87d071707a8..98cf4d41c10 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -213,7 +213,9 @@ struct wayland_surface
     int buffer_width, buffer_height;
     HCURSOR hcursor;
     enum wayland_surface_role role;
-    HWND parent_hwnd;
+    LONG weak_ref;
+    BOOL destroyed;
+    struct wayland_surface *parent_weak_ref;
 };
 
 struct wayland_shm_buffer
@@ -247,6 +249,9 @@ void wayland_output_use_xdg_extension(struct wayland_output *output);
  */
 
 struct wayland_surface *wayland_surface_create(HWND hwnd);
+struct wayland_surface *wayland_surface_get_weak_ref(struct wayland_surface *surface);
+void wayland_surface_release_weak_ref(struct wayland_surface *surface);
+struct wayland_surface *wayland_surface_lock_weak_ref(struct wayland_surface *surface);
 void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_make_toplevel(struct wayland_surface *surface);
 void wayland_surface_make_subsurface(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 6ee3707357a..4f3daca14d4 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -247,7 +247,8 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     if ((role == WAYLAND_SURFACE_ROLE_TOPLEVEL) != !!(surface->xdg_toplevel) ||
         (role == WAYLAND_SURFACE_ROLE_SUBSURFACE) != !!(surface->wl_subsurface) ||
-        (role == WAYLAND_SURFACE_ROLE_SUBSURFACE && surface->parent_hwnd != parent_data->hwnd))
+        (role == WAYLAND_SURFACE_ROLE_SUBSURFACE &&
+         surface->parent_weak_ref && surface->parent_weak_ref->hwnd != parent_data->hwnd))
     {
         /* If we have a pre-existing surface ensure it has no role. */
         if (data->wayland_surface) wayland_surface_clear_role(surface);
@@ -297,7 +298,8 @@ static void wayland_win_data_update_wayland_state(struct wayland_win_data *data)
 
     if (surface->wl_subsurface)
     {
-        TRACE("hwnd=%p subsurface parent=%p\n", surface->hwnd, surface->parent_hwnd);
+        TRACE("hwnd=%p subsurface parent=%p\n", surface->hwnd,
+              surface->parent_weak_ref ? surface->parent_weak_ref->hwnd : 0);
         /* Although subsurfaces don't have a dedicated surface config mechanism,
          * we use the config fields to mark them as updated. */
         surface->processing.serial = 1;
-- 
GitLab


From f351394e6da328844c0b1453b58e0d805a0f1f44 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 11 Jul 2024 17:39:01 +0300
Subject: [PATCH 5/8] winewayland: Support Wayland surface role changes.

Windows supports changing between the WS_CHILD and WS_POPUP window
styles which requires a Wayland surface role change between
wl_subsurface and xdg_toplevel.

Since Wayland doesn't support changing a surface's role, to support this
scenario we recreate the Wayland surface and adjust any related
subsurfaces to use the new parent surface.
---
 dlls/winewayland.drv/wayland_surface.c | 31 +++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 +
 dlls/winewayland.drv/window.c          | 54 +++++++++++++++++++++-----
 3 files changed, 78 insertions(+), 9 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 57fd217e0d3..4ace7a16246 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -1004,6 +1004,37 @@ err:
     return NULL;
 }
 
+/**********************************************************************
+ *          wayland_surface_attach_client
+ */
+void wayland_surface_attach_client(struct wayland_surface *surface,
+                                   struct wayland_client_surface *client)
+{
+    assert(!surface->client && client);
+
+    if (client->wl_subsurface) wl_subsurface_destroy(client->wl_subsurface);
+
+    /* Create a new subsurface that it is attached to the proper parent. */
+    client->wl_subsurface =
+        wl_subcompositor_get_subsurface(process_wayland.wl_subcompositor,
+                                        client->wl_surface,
+                                        surface->wl_surface);
+    if (!client->wl_subsurface)
+    {
+        ERR("Failed to create client wl_subsurface\n");
+        return;
+    }
+    /* Present contents independently of the parent surface. */
+    wl_subsurface_set_desync(client->wl_subsurface);
+
+    InterlockedIncrement(&client->ref);
+    surface->client = client;
+
+    wayland_surface_reconfigure_client(surface);
+    /* Commit to apply subsurface positioning. */
+    wl_surface_commit(surface->wl_surface);
+}
+
 static void dummy_buffer_release(void *data, struct wl_buffer *buffer)
 {
     struct wayland_shm_buffer *shm_buffer = data;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 98cf4d41c10..87e0d29ef0c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -273,6 +273,8 @@ void wayland_surface_coords_to_window(struct wayland_surface *surface,
                                       int *window_x, int *window_y);
 struct wayland_client_surface *wayland_surface_get_client(struct wayland_surface *surface);
 BOOL wayland_client_surface_release(struct wayland_client_surface *client);
+void wayland_surface_attach_client(struct wayland_surface *surface,
+                                   struct wayland_client_surface *client);
 void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 4f3daca14d4..617ad6e392c 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -36,6 +36,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+#define UWS_FORCE_ROLE_UPDATE 0x01
 
 /**********************************************************************
  *       get_win_monitor_dpi
@@ -215,14 +216,18 @@ static void reapply_cursor_clipping(void)
     NtUserSetThreadDpiAwarenessContext(context);
 }
 
-static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
+static void wayland_win_data_update_wayland_state(struct wayland_win_data *data);
+
+static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data, UINT flags)
 {
     struct wayland_surface *surface = data->wayland_surface;
-    struct wayland_win_data *parent_data;
+    struct wayland_win_data *parent_data, *wwd;
     enum wayland_surface_role role;
+    BOOL surface_changed = FALSE;
+    struct wayland_client_surface *client = NULL;
     WCHAR text[1024];
 
-    TRACE("hwnd=%p\n", data->hwnd);
+    TRACE("hwnd=%p flags=0x%x\n", data->hwnd, flags);
 
     if (NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_VISIBLE)
     {
@@ -236,19 +241,33 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
         role = WAYLAND_SURFACE_ROLE_NONE;
 
     /* We can temporarily remove a role from a wayland surface and add it back,
-     * but we can't change a surface's role.
-     * TODO: Recreate the surface to allow role change. */
-    if (surface && role && surface->role && role != surface->role) goto out;
+     * but we can't change a surface's role. */
+    if (surface && role && surface->role && role != surface->role)
+    {
+        if (data->window_surface)
+            wayland_window_surface_update_wayland_surface(data->window_surface, NULL, NULL);
+        pthread_mutex_lock(&surface->mutex);
+        if (surface->client) client = wayland_surface_get_client(surface);
+        pthread_mutex_unlock(&surface->mutex);
+        wayland_surface_destroy(surface);
+        surface = NULL;
+    }
 
     /* Ensure that we have a wayland surface. */
-    if (!surface && !(surface = wayland_surface_create(data->hwnd))) goto out;
+    if (!surface)
+    {
+        surface = wayland_surface_create(data->hwnd);
+        surface_changed = data->wayland_surface || surface;
+        if (!surface) goto out;
+    }
 
     pthread_mutex_lock(&surface->mutex);
 
     if ((role == WAYLAND_SURFACE_ROLE_TOPLEVEL) != !!(surface->xdg_toplevel) ||
         (role == WAYLAND_SURFACE_ROLE_SUBSURFACE) != !!(surface->wl_subsurface) ||
         (role == WAYLAND_SURFACE_ROLE_SUBSURFACE &&
-         surface->parent_weak_ref && surface->parent_weak_ref->hwnd != parent_data->hwnd))
+         surface->parent_weak_ref && surface->parent_weak_ref->hwnd != parent_data->hwnd) ||
+        (flags & UWS_FORCE_ROLE_UPDATE))
     {
         /* If we have a pre-existing surface ensure it has no role. */
         if (data->wayland_surface) wayland_surface_clear_role(surface);
@@ -273,6 +292,7 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
     }
 
     wayland_win_data_get_config(data, &surface->window);
+    if (client) wayland_surface_attach_client(surface, client);
 
     pthread_mutex_unlock(&surface->mutex);
 
@@ -287,6 +307,22 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 out:
     TRACE("hwnd=%p surface=%p=>%p\n", data->hwnd, data->wayland_surface, surface);
     data->wayland_surface = surface;
+    if (client) wayland_client_surface_release(client);
+
+    /* If the surface for this hwnd changed, update child surfaces. */
+    if (surface_changed)
+    {
+        RB_FOR_EACH_ENTRY(wwd, &win_data_rb, struct wayland_win_data, entry)
+        {
+            if (wwd->wayland_surface && NtUserGetAncestor(wwd->hwnd, GA_PARENT) == data->hwnd)
+            {
+                /* wayland_win_data_update_wayland_surface doesn't detect a surface
+                 * change without a window change, so force a role update. */
+                wayland_win_data_update_wayland_surface(wwd, UWS_FORCE_ROLE_UPDATE);
+                if (wwd->wayland_surface) wayland_win_data_update_wayland_state(wwd);
+            }
+        }
+    }
 }
 
 static void wayland_win_data_update_wayland_state(struct wayland_win_data *data)
@@ -520,7 +556,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
     if (data->window_surface) window_surface_release(data->window_surface);
     data->window_surface = surface;
 
-    wayland_win_data_update_wayland_surface(data);
+    wayland_win_data_update_wayland_surface(data, 0);
     if (data->wayland_surface) wayland_win_data_update_wayland_state(data);
 
     wayland_win_data_release(data);
-- 
GitLab


From e56db5538fc13277fec23caec290c8634a048551 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 11 Jul 2024 16:29:48 +0300
Subject: [PATCH 6/8] winewayland: Ensure parent surface contents for
 accelerated windows.

---
 dlls/winewayland.drv/opengl.c | 26 +++++++++++++++-----------
 dlls/winewayland.drv/vulkan.c |  4 +++-
 2 files changed, 18 insertions(+), 12 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 994154968b3..eaf07cabc6a 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -267,21 +267,25 @@ static void wayland_gl_drawable_sync_size(struct wayland_gl_drawable *gl)
 static void wayland_gl_drawable_sync_surface_state(struct wayland_gl_drawable *gl)
 {
     struct wayland_surface *wayland_surface;
+    HWND hwnd = gl->hwnd;
 
-    if (!(wayland_surface = wayland_surface_lock_hwnd(gl->hwnd))) return;
+    while (hwnd && (wayland_surface = wayland_surface_lock_hwnd(hwnd)))
+    {
+        wayland_surface_ensure_contents(wayland_surface);
 
-    wayland_surface_ensure_contents(wayland_surface);
+        /* Handle any processed configure request, to ensure the related
+         * surface state is applied by the compositor. */
+        if (wayland_surface->processing.serial &&
+            wayland_surface->processing.processed &&
+            wayland_surface_reconfigure(wayland_surface))
+        {
+            wl_surface_commit(wayland_surface->wl_surface);
+        }
 
-    /* Handle any processed configure request, to ensure the related
-     * surface state is applied by the compositor. */
-    if (wayland_surface->processing.serial &&
-        wayland_surface->processing.processed &&
-        wayland_surface_reconfigure(wayland_surface))
-    {
-        wl_surface_commit(wayland_surface->wl_surface);
+        hwnd = wayland_surface->parent_weak_ref ?
+               wayland_surface->parent_weak_ref->hwnd : 0;
+        pthread_mutex_unlock(&wayland_surface->mutex);
     }
-
-    pthread_mutex_unlock(&wayland_surface->mutex);
 }
 
 static BOOL wgl_context_make_current(struct wgl_context *ctx, HWND draw_hwnd,
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 16084175013..337bfb823d0 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -140,7 +140,7 @@ static void wayland_vulkan_surface_presented(HWND hwnd, VkResult result)
 {
     struct wayland_surface *wayland_surface;
 
-    if ((wayland_surface = wayland_surface_lock_hwnd(hwnd)))
+    while (hwnd && (wayland_surface = wayland_surface_lock_hwnd(hwnd)))
     {
         wayland_surface_ensure_contents(wayland_surface);
 
@@ -153,6 +153,8 @@ static void wayland_vulkan_surface_presented(HWND hwnd, VkResult result)
             wl_surface_commit(wayland_surface->wl_surface);
         }
 
+        hwnd = wayland_surface->parent_weak_ref ?
+               wayland_surface->parent_weak_ref->hwnd : 0;
         pthread_mutex_unlock(&wayland_surface->mutex);
     }
 }
-- 
GitLab


From 385582d824dce17806270d1e1f8b178db97c8ff6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 12 Jul 2024 10:18:05 +0300
Subject: [PATCH 7/8] winewayland: Create Wayland surfaces for child windows on
 demand.

Wayland surfaces for child windows are currently only needed to render
GL/VK contents, so instead of creating them for all child windows,
create them only when GL/VK needs them.

Furthermore, these child window Wayland surfaces will now be anchored
directly to their top-level parent to avoid unnecessary nested
subsurface chains.
---
 dlls/winewayland.drv/opengl.c     |  2 +-
 dlls/winewayland.drv/vulkan.c     |  2 +-
 dlls/winewayland.drv/waylanddrv.h |  1 +
 dlls/winewayland.drv/window.c     | 99 ++++++++++++++++++++++++++++---
 4 files changed, 93 insertions(+), 11 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index eaf07cabc6a..473ab4e23c3 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -165,7 +165,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     /* Get the client surface for the HWND. If don't have a wayland surface
      * (e.g., HWND_MESSAGE windows) just create a dummy surface to act as the
      * target render surface. */
-    if ((wayland_surface = wayland_surface_lock_hwnd(hwnd)))
+    if ((wayland_surface = wayland_surface_lock_accel_hwnd(hwnd)))
     {
         gl->client = wayland_surface_get_client(wayland_surface);
         client_width = wayland_surface->window.client_rect.right -
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 337bfb823d0..9d73d80b1c3 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -85,7 +85,7 @@ static VkResult wayland_vulkan_surface_create(HWND hwnd, VkInstance instance, Vk
 
     TRACE("%p %p %p %p\n", hwnd, instance, surface, private);
 
-    wayland_surface = wayland_surface_lock_hwnd(hwnd);
+    wayland_surface = wayland_surface_lock_accel_hwnd(hwnd);
     if (!wayland_surface)
     {
         ERR("Failed to find wayland surface for hwnd=%p\n", hwnd);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 87e0d29ef0c..378d408a719 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -261,6 +261,7 @@ void wayland_surface_attach_shm(struct wayland_surface *surface,
                                 struct wayland_shm_buffer *shm_buffer,
                                 HRGN surface_damage_region);
 struct wayland_surface *wayland_surface_lock_hwnd(HWND hwnd);
+struct wayland_surface *wayland_surface_lock_accel_hwnd(HWND hwnd);
 BOOL wayland_surface_reconfigure(struct wayland_surface *surface);
 BOOL wayland_surface_config_is_compatible(struct wayland_surface_config *conf,
                                           int width, int height,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 617ad6e392c..e160ef9ce12 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -36,7 +36,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
-#define UWS_FORCE_ROLE_UPDATE 0x01
+#define UWS_FORCE_ROLE_UPDATE  0x01
+#define UWS_FORCE_CREATE       0x02
+#define UWS_NO_UPDATE_CHILDREN 0x04
 
 /**********************************************************************
  *       get_win_monitor_dpi
@@ -216,6 +218,37 @@ static void reapply_cursor_clipping(void)
     NtUserSetThreadDpiAwarenessContext(context);
 }
 
+static struct wayland_win_data *wayland_win_data_get_top_parent(struct wayland_win_data *data)
+{
+    HWND desktop = NtUserGetDesktopWindow(), cur = data->hwnd, parent;
+
+    while ((parent = NtUserGetAncestor(cur, GA_PARENT)) && parent != desktop)
+        cur = parent;
+
+    /* Don't return ourselves */
+    return cur == data->hwnd ? NULL : wayland_win_data_get_nolock(cur);
+}
+
+static BOOL wayland_win_data_needs_wayland_surface(struct wayland_win_data *data)
+{
+    HWND parent = NtUserGetAncestor(data->hwnd, GA_PARENT);
+
+    /* We want a Wayland surface for toplevel windows. */
+    if (!parent || parent == NtUserGetDesktopWindow()) return TRUE;
+
+    /* We want to keep the Wayland surface if we have a client area subsurface. */
+    if (data->wayland_surface)
+    {
+        BOOL has_client;
+        pthread_mutex_lock(&data->wayland_surface->mutex);
+        has_client = !!data->wayland_surface->client;
+        pthread_mutex_unlock(&data->wayland_surface->mutex);
+        if (has_client) return TRUE;
+    }
+
+    return FALSE;
+}
+
 static void wayland_win_data_update_wayland_state(struct wayland_win_data *data);
 
 static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data, UINT flags)
@@ -229,9 +262,24 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     TRACE("hwnd=%p flags=0x%x\n", data->hwnd, flags);
 
-    if (NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_VISIBLE)
+    /* Destroy unused surfaces of child windows. */
+    if (!wayland_win_data_needs_wayland_surface(data) && !(flags & UWS_FORCE_CREATE))
+    {
+        if (surface)
+        {
+            if (data->window_surface)
+                wayland_window_surface_update_wayland_surface(data->window_surface, NULL, NULL);
+            wayland_surface_destroy(surface);
+            surface = NULL;
+            surface_changed = TRUE;
+        }
+        goto out;
+    }
+
+    if (NtUserIsWindowVisible(data->hwnd))
     {
-        parent_data = wayland_win_data_get_nolock(NtUserGetAncestor(data->hwnd, GA_PARENT));
+        /* We anchor child windows to their toplevel parent window. */
+        parent_data = wayland_win_data_get_top_parent(data);
         if (parent_data && parent_data->wayland_surface)
             role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
         else
@@ -309,16 +357,18 @@ out:
     data->wayland_surface = surface;
     if (client) wayland_client_surface_release(client);
 
-    /* If the surface for this hwnd changed, update child surfaces. */
-    if (surface_changed)
+    if (!(flags & UWS_NO_UPDATE_CHILDREN))
     {
+        /* Update child window surfaces, but do not allow recursive updates. */
+        UINT wwd_flags = UWS_NO_UPDATE_CHILDREN;
+        /* wayland_win_data_update_wayland_surface doesn't detect a surface
+         * change without a window change, so force a role update. */
+        if (surface_changed) wwd_flags |= UWS_FORCE_ROLE_UPDATE;
         RB_FOR_EACH_ENTRY(wwd, &win_data_rb, struct wayland_win_data, entry)
         {
-            if (wwd->wayland_surface && NtUserGetAncestor(wwd->hwnd, GA_PARENT) == data->hwnd)
+            if (wwd->wayland_surface && NtUserIsChild(data->hwnd, wwd->hwnd))
             {
-                /* wayland_win_data_update_wayland_surface doesn't detect a surface
-                 * change without a window change, so force a role update. */
-                wayland_win_data_update_wayland_surface(wwd, UWS_FORCE_ROLE_UPDATE);
+                wayland_win_data_update_wayland_surface(wwd, wwd_flags);
                 if (wwd->wayland_surface) wayland_win_data_update_wayland_state(wwd);
             }
         }
@@ -805,6 +855,8 @@ void wayland_window_flush(HWND hwnd)
 
 /**********************************************************************
  *           wayland_surface_lock_hwnd
+ *
+ *  Get the locked surface for a window.
  */
 struct wayland_surface *wayland_surface_lock_hwnd(HWND hwnd)
 {
@@ -819,3 +871,32 @@ struct wayland_surface *wayland_surface_lock_hwnd(HWND hwnd)
 
     return surface;
 }
+
+/**********************************************************************
+ *           wayland_surface_lock_accel_hwnd
+ *
+ *  Get the locked surface for a window, creating the surface for a child
+ *  on demand if needed, so accelerated content can be presented into it.
+ */
+struct wayland_surface *wayland_surface_lock_accel_hwnd(HWND hwnd)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+    struct wayland_surface *surface;
+
+    if (!data) return NULL;
+
+    /* If the hwnd is a child window we can anchor to some toplevel,
+     * create a wayland surface for it to be the target of accelerated
+     * rendering. */
+    if (!data->wayland_surface && wayland_win_data_get_top_parent(data))
+    {
+        wayland_win_data_update_wayland_surface(data, UWS_FORCE_CREATE);
+        if (data->wayland_surface) wayland_win_data_update_wayland_state(data);
+    }
+
+    if ((surface = data->wayland_surface)) pthread_mutex_lock(&surface->mutex);
+
+    wayland_win_data_release(data);
+
+    return surface;
+}
-- 
GitLab


From ab146f1724dba7e7a6c125a1178ffcdf5632d50d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 23 Jul 2024 15:06:43 +0300
Subject: [PATCH 8/8] winewayland: Improve integration of GDI rendering with
 accelerated content.

Created dedicated Wayland surfaces and window surfaces for child windows
whose contents may be obscured by the client area subsurfaces we
use to display accelerated content.
---
 dlls/winewayland.drv/window.c | 30 ++++++++++++++++++++++++------
 1 file changed, 24 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e160ef9ce12..ca1bdca5ddb 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -229,7 +229,8 @@ static struct wayland_win_data *wayland_win_data_get_top_parent(struct wayland_w
     return cur == data->hwnd ? NULL : wayland_win_data_get_nolock(cur);
 }
 
-static BOOL wayland_win_data_needs_wayland_surface(struct wayland_win_data *data)
+static BOOL wayland_win_data_needs_wayland_surface(struct wayland_win_data *data,
+                                                   struct wayland_win_data *parent_data)
 {
     HWND parent = NtUserGetAncestor(data->hwnd, GA_PARENT);
 
@@ -246,6 +247,17 @@ static BOOL wayland_win_data_needs_wayland_surface(struct wayland_win_data *data
         if (has_client) return TRUE;
     }
 
+    /* We want a Wayland surface if the parent has a client area subsurface
+     * which may obscure our contents (as a child window of that parent). */
+    if (parent_data->wayland_surface)
+    {
+        BOOL parent_has_client;
+        pthread_mutex_lock(&parent_data->wayland_surface->mutex);
+        parent_has_client = !!parent_data->wayland_surface->client;
+        pthread_mutex_unlock(&parent_data->wayland_surface->mutex);
+        if (parent_has_client) return TRUE;
+    }
+
     return FALSE;
 }
 
@@ -262,8 +274,12 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     TRACE("hwnd=%p flags=0x%x\n", data->hwnd, flags);
 
+    /* We anchor child windows to their toplevel parent window. */
+    parent_data = wayland_win_data_get_top_parent(data);
+
     /* Destroy unused surfaces of child windows. */
-    if (!wayland_win_data_needs_wayland_surface(data) && !(flags & UWS_FORCE_CREATE))
+    if (!wayland_win_data_needs_wayland_surface(data, parent_data) &&
+        !(flags & UWS_FORCE_CREATE))
     {
         if (surface)
         {
@@ -278,8 +294,6 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     if (NtUserIsWindowVisible(data->hwnd))
     {
-        /* We anchor child windows to their toplevel parent window. */
-        parent_data = wayland_win_data_get_top_parent(data);
         if (parent_data && parent_data->wayland_surface)
             role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
         else
@@ -564,8 +578,12 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const REC
     if (!data && !(data = wayland_win_data_create(hwnd, window_rect, client_rect, visible_rect)))
         return FALSE; /* use default surface */
 
-    parent = NtUserGetAncestor(hwnd, GA_PARENT);
-    if ((parent && parent != NtUserGetDesktopWindow())) goto done; /* use default surface */
+    /* Use the default surface for child windows, unless we need a dedicated
+     * wayland surface in which case use a dedicated window surface. */
+     parent = NtUserGetAncestor(hwnd, GA_PARENT);
+     if (parent && parent != NtUserGetDesktopWindow() &&
+         !wayland_win_data_needs_wayland_surface(data, wayland_win_data_get_top_parent(data)))
+        goto done; /* use default surface */
 
     ret = TRUE;
 
-- 
GitLab

